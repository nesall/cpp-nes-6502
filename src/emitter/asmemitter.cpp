#include "nesdefs.hpp"
#include "asmemitter.hpp"
#define FMT_HEADER_ONLY
#include <3rdparty/fmt/format.h>
#include <cassert>

namespace cppnes {
  namespace {
    struct OperandFormatter {
      const AsmEmitterOptions &opts;

      std::string operator()(std::monostate)         const { return ""; }
      std::string operator()(Accumulator)            const { return "A"; }
      std::string operator()(Immediate i)            const { return fmt::format("#${:02X}", i.value); }
      std::string operator()(ZeroPage zp)            const {
        auto s = fmt::format("${:02X}", zp.addr.value());
        if (opts.emitComments && !zp.addr.name().empty())
          s += fmt::format("             ; {}", zp.addr.name());
        return s;
      }
      std::string operator()(Absolute abs)           const { return fmt::format("${:04X}", abs.addr.value()); }
      std::string operator()(AbsoluteX abs)          const { return fmt::format("${:04X},X", abs.addr.value()); }
      std::string operator()(AbsoluteY abs)          const { return fmt::format("${:04X},Y", abs.addr.value()); }
      std::string operator()(ZeroPageX zp)           const { return fmt::format("${:02X},X", zp.addr.value()); }
      std::string operator()(ZeroPageY zp)           const { return fmt::format("${:02X},Y", zp.addr.value()); }
      std::string operator()(Indirect ind)           const { return fmt::format("(${:04X})", ind.addr.value()); }
      std::string operator()(IndexedIndirectX ind)   const { return fmt::format("(${:02X},X)", ind.addr.value()); }
      std::string operator()(IndexedIndirectY ind)   const { return fmt::format("(${:02X}),Y", ind.addr.value()); }
      std::string operator()(const Label &l)         const { return std::string(l.name()); }
    };
  } // anonymous namespace
} // namespace cppnes

cppnes::AsmEmitter::AsmEmitter(const AsmEmitterOptions &options) : options_(options)
{
}

void cppnes::AsmEmitter::emitPrgAsm(const Program &program, std::ostream &out) const {
  out << ".segment \"CODE\"\n\n";

  for (const auto &sub : program.subroutines()) {
    out << ".proc " << sub->name() << "\n";
    for (const auto &entry : sub->instructions())
      out << formatEntry(entry) << "\n";
    out << ".endproc\n\n";
  }

  out << formatVectors(program);
  out << "\n";
}

void cppnes::AsmEmitter::emitLinkerConfig(std::ostream &out) const {
  out <<
    "MEMORY {\n"
    "  HEADER:  start = $0000, size = $0010, fill = yes;\n"
    "  PRG:     start = $8000, size = $8000, fill = yes, fillval = $FF;\n"
    "  CHR:     start = $0000, size = $2000, fill = yes, fillval = $00;\n"
    "}\n\n"
    "SEGMENTS {\n"
    "  HEADER:  load = HEADER, type = ro;\n"
    "  CODE:    load = PRG,    type = ro,  start = $8000;\n"
    "  VECTORS: load = PRG,    type = ro,  start = $FFFA;\n"
    "  CHARS:   load = CHR,    type = ro;\n"
    "}\n";
}

void cppnes::AsmEmitter::emitInesHeader(const Rom &rom, std::ostream &out) const {
  // iNES header — 16 bytes
  // ca65 emits this as part of the HEADER segment
  out << "; Generated by cpp-nes-6502\n"
    << "; --------------------------\n\n";
  out << ".segment \"HEADER\"\n"
    << fmt::format("  .byte $4E, $45, $53, $1A  ; 'NES' + MS-DOS EOF\n")
    << fmt::format("  .byte $02                  ; PRG-ROM size (2 x 16KB)\n")
    << fmt::format("  .byte $01                  ; CHR-ROM size (1 x 8KB)\n")
    << fmt::format("  .byte ${:02X}                  ; Mapper low / mirroring\n",
      rom.mirroringByte())
    << fmt::format("  .byte $00                  ; Mapper high\n")
    << "  .byte $00, $00, $00, $00, $00, $00, $00, $00  ; padding\n; Header is total 16 bytes.\n\n";
}

void cppnes::AsmEmitter::emitChars(const Resources &rc, std::ostream &out) const
{
  const auto &chr = rc.chrData();
  out << ".segment \"CHARS\"\n";

  if (chr.empty()) {
    out << "; WARNING: No CHR data loaded\n";
    out << ".res 8192 ; Reserving 8192 bytes of blank space\n";
    out << "\n";
    return;
  }

  constexpr size_t bytesPerLine = 16;
  for (size_t i = 0; i < chr.size(); i += bytesPerLine) {
    out << "    .byte ";
    size_t lineEnd = std::min(i + bytesPerLine, chr.size());
    for (size_t j = i; j < lineEnd; ++j) {
      out << fmt::format("${:02X}", chr[j]);
      if (j < lineEnd - 1) out << ", ";
    }
    // Comment: byte offset, useful for debugging tile boundaries
    if (options_.emitComments) {
      size_t tile = i / 16;
      out << fmt::format("  ; tile {:03d} offset ${:04X}", tile, i);
    }
    out << "\n";
  }
  out << "\n";
}

void cppnes::AsmEmitter::emitStartup(std::ostream &out) const
{
  out << ".segment \"STARTUP\"\n";
}

std::string cppnes::AsmEmitter::formatEntry(const Entry &entry) const {
  return std::visit([this](const auto &e) -> std::string {
    using T = std::decay_t<decltype(e)>;
    if constexpr (std::is_same_v<T, Instruction>)
      return formatInstruction(e);
    else if constexpr (std::is_same_v<T, LabelDef>)
      return formatLabelDef(e);
    else
      static_assert(false, "Unhandled Entry type");
    }, entry);
}

std::string cppnes::AsmEmitter::formatInstruction(const Instruction &inst) const
{
  std::string line = "  " + opcodeToString(inst.opcode);
  std::string operand = std::visit(OperandFormatter{ options_ }, inst.operand);
  if (!operand.empty()) line += " " + operand;
  return line;
}

std::string cppnes::AsmEmitter::formatLabelDef(const LabelDef &ldef) const
{
  return fmt::format("{}:", ldef.label.name());
}

std::string cppnes::AsmEmitter::formatVectors(const Program &prg) const
{
  assert(prg.nmiVector() && prg.resetVector() && prg.irqVector());
  auto vec = [](const Subroutine *s) -> std::string {
    return s ? std::string(s->name()) : "0";
    };
  return fmt::format(
    ".segment \"VECTORS\"\n"
    "  .word {} ; NMI\n"
    "  .word {} ; RESET\n"
    "  .word {} ; IRQ\n",
    vec(prg.nmiVector()),
    vec(prg.resetVector()),
    vec(prg.irqVector()));
}

std::string cppnes::AsmEmitter::opcodeToString(Opcode op) const
{
  switch (op) {
  case Opcode::LDA: return "LDA";
  case Opcode::STA: return "STA";
  case Opcode::LDX: return "LDX";
  case Opcode::STX: return "STX";
  case Opcode::LDY: return "LDY";
  case Opcode::STY: return "STY";
  case Opcode::ADC: return "ADC";
  case Opcode::SBC: return "SBC";
  case Opcode::ASL: return "ASL";
  case Opcode::LSR: return "LSR";
  case Opcode::ROL: return "ROL";
  case Opcode::ROR: return "ROR";
  case Opcode::BIT: return "BIT";
  case Opcode::AND: return "AND";
  case Opcode::ORA: return "ORA";
  case Opcode::EOR: return "EOR";
  case Opcode::CMP: return "CMP";
  case Opcode::CPX: return "CPX";
  case Opcode::CPY: return "CPY";
  case Opcode::JMP: return "JMP";
  case Opcode::JSR: return "JSR";
  case Opcode::RTS: return "RTS";
  case Opcode::BCC: return "BCC";
  case Opcode::BCS: return "BCS";
  case Opcode::INX: return "INX";
  case Opcode::INY: return "INY";
  case Opcode::DEX: return "DEX";
  case Opcode::DEY: return "DEY";
  case Opcode::INC: return "INC";
  case Opcode::DEC: return "DEC";
  case Opcode::BEQ: return "BEQ";
  case Opcode::BMI: return "BMI";
  case Opcode::BNE: return "BNE";
  case Opcode::BPL: return "BPL";
  case Opcode::BVC: return "BVC";
  case Opcode::BVS: return "BVS";
  case Opcode::BRK: return "BRK";
  case Opcode::PHP: return "PHP";
  case Opcode::PLP: return "PLP";
  case Opcode::PHA: return "PHA";
  case Opcode::PLA: return "PLA";
  case Opcode::CLC: return "CLC";
  case Opcode::SEC: return "SEC";
  case Opcode::CLI: return "CLI";
  case Opcode::SEI: return "SEI";
  case Opcode::CLV: return "CLV";
  case Opcode::CLD: return "CLD";
  case Opcode::SED: return "SED";
  case Opcode::RTI: return "RTI";
  case Opcode::TAX: return "TAX";
  case Opcode::TXA: return "TXA";
  case Opcode::TAY: return "TAY";
  case Opcode::TYA: return "TYA";
  case Opcode::TSX: return "TSX";
  case Opcode::TXS: return "TXS";
  case Opcode::NOP: return "NOP";
  default:
    throw std::runtime_error(fmt::format("Unknown opcode: {}", static_cast<int>(op)));
  }
}
